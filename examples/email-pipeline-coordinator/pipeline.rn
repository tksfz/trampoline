struct Task {
  type_name,
  data
}

async fn handle(client, typ, data) {
  match typ {
    "email-pipeline-start" => {
      Task {
        type_name: "email-pipeline-fetch-users",
        data: #{
          "email_subject": data.get("email_subject"),
        }
      }
    }
    ,
    "email-pipeline-fetch-users" => {
      let res = json::from_string(http::get("http://localhost:3000/users").await?.text().await?)?;
      res.iter().map(|u| Task {
        type_name: "email-pipeline-generate-email",
        data: #{
          "email_address": u,
          "email_subject": data.get("email_subject"),
        }
      }).collect::<Vec>()
    },
    "email-pipeline-generate-email" => {
      let res = http::get(`http://localhost:3000/generate-email?email_address=${data["email_address"]}`).await?;
      let res = res.text().await?;
      let email_data = json::from_string(res)?;
      Task {
        type_name: "email-pipeline-send-email",
        data: #{
          "email_address": email_data["email_address"],
          "email_subject": email_data["email_subject"],
          "email_body": email_data["email_body"],
        }
      }
    },
    "email-pipeline-send-email" => {
      let body = #{
        "email_address": data["email_address"],
        "email_subject": data["email_subject"],
        "email_body": data["email_body"],
      };
      let res = client.post("http://localhost:3000/send-email")
        .header("Content-Type", "application/json")
        .body_bytes(json::to_bytes(body)?)
        .send().await?
        .text().await?;
      let success = json::from_string(res)?;
      Task {
        type_name: "email-pipeline-record-send-result",
        data: #{
          "email_address": data.email_address,
          "successful": success,
        }
      }
    },
    "email-pipeline-record-send-result" => {
      []
    },
    _ => Err("invalid task type")
  }
}

pub async fn main() {
  let client = http::Client::new();
  let tasks = Vec::new();
  tasks.push(Task { type_name: "email-pipeline-fetch-users", data: #{} });
  loop {
    let task = tasks.pop();
    match task {
      Some(task) => {
        dbg(task);
        let result = handle(client, task.type_name, task.data).await;
        dbg(result);
        let result_tasks = match result {
          task if result is Task => [ task ],
          vec if result is Vec => vec,
        };
        for result_task in result_tasks {
          tasks.push(result_task);
        }
      },
      None => {
        break;
      }
    }
  }
}
